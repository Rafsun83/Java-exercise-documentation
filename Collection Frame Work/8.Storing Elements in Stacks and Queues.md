# Overview
> Java SE 5 saw the addition of a new interface in the Collections Framework: the `Queue` interface, further extended in Java SE 6 by the `Deque` interface. The `Queue` interface is an extension of the `Collection` interface.

<img src="../Assets/Images/QueueHairarkey.png">

## 1.Stack (LIFO – Last In, First Out)
#### **Hierarchy of Stack in Java:**
```java
java.util.Collection
        ↑
java.util.List
        ↑
java.util.Vector
        ↑
java.util.Stack
```
- **A Stack follows the LIFO principle.**
- Operations:
  - `push(element)`: Adds an element to the top.
  - `pop()`: Removes the top element
  - `peek()`: Views the top element without removing it.
- **Example of Stack Operations:**
```java
Stack<Integer> stack = new Stack<>();

// Push elements
stack.push(10);
stack.push(20);
stack.push(30);

System.out.println("Top element (peek): " + stack.peek()); // 30
System.out.println("Popped element: " + stack.pop()); // 30
System.out.println("Stack after pop: " + stack);//[10, 20]
```
#### FAQ: 
 ##### A. Why new Stack<>() for Stack? 
1. `Stack` is a concrete class, so we can directly instantiate it.
2. It extends `Vector`, which provides thread safety but is not the most efficient choice
3. **Modern Alternative:** `Deque<Integer> stack = new ArrayDeque<>();`
4. `ArrayDeque` is recommended because it is faster and more efficient than `Stack`.

## 2.Queue (FIFO – First In, First Out)
#### **Hierarchy of Queue in Java:**
```java
        java.util.Collection
                ↑
         java.util.Queue
                ↑
    java.util.LinkedList (implements Queue)
```
- **A `Queue` follows the FIFO principle.**
- Operations:
  - `offer(element)`: Adds an element to the queue.
  - `poll()`: Removes the oldest element.
  - `peek()`: Views the front element without removing it.
- **Example of `Queue` Operations:**
```java
Queue<Integer> queue = new LinkedList<>();
queue.add(1); 
queue.offer(2);
queue.offer(3);
System.out.println("queue" + queue); //[1, 2, 3]
System.out.println(queue.peek()); // 1
System.out.println(queue.poll()); // 1
System.out.println(queue.remove()); // 2
System.out.println("queue" + queue); //[3]
```

#### FAQ:
##### A. Why new LinkedList<>() for Queue?
1. `Queue` is an interface, so we need a concrete class to instantiate it.
2. `LinkedList` is a commonly used implementation of `Queue`, offering efficient FIFO behavior.
3. `LinkedList` implements both Queue and Deque, making it more flexible.
##### B. What is the Alternative Implementations for Queue?
1. `PriorityQueue<>` (Maintains natural order).
2. `ArrayDeque<>` (Efficient and recommended over LinkedList for queues).
##### C. What is difference between `offer()` and `add()` ?
> Both offer(E e) and add(E e) methods are used to insert elements into a Queue in Java. However, they behave differently when the queue is full or has capacity restrictions.

| Feature  | `add(E e)` | `offer(E e)` |
|----------|------------|------------|
| Return Type | `boolean` (always `true`) | `boolean` (`true` if successful, `false` if full) |
| Behavior When Full | Throws `IllegalStateException` | Returns `false` |
| Suitable For | When queue should not silently fail | When queue should not throw exceptions |
| Preferred For | Unbounded Queues | Bounded Queues |

