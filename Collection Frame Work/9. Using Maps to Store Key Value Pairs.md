# Overview
> The Map interface in Java is part of the Java Collections Framework and is used to store key-value pairs. Unlike `Collection`, `Map` does not allow duplicate keys but allows duplicate values.

## Hierarchy of Map Interface

```java
                Map<K, V>  (Interface)
                    │
                implements
    ┌───────────────┼──────────────────┐
    │               │                  │
 HashMap        LinkedHashMap       TreeMap
    │               │                  │
    └── WeakHashMap └── IdentityHashMap └── ConcurrentHashMap

```

### Key points of `Map()`
1. `Map<K, V>` is the parent interface.
2. `HashMap`, `TreeMap`, and `LinkedHashMap` are the most commonly used implementations.
3. `ConcurrentHashMap` is used in **multi-threaded** environments.
4. `WeakHashMap` and `IdentityHashMap` serve specific purposes.

## Example Implementations of `map()`:

### 1. HashMap (Most Common)
- `Unordered` key-value storage.
- **Allows** `null` keys and values.
- **Fastest** in most cases.
```java
Map<Integer, String> map = new HashMap<>();
map.put(1, "A");
map.put(2, "B");
System.out.println(map); // {1=A, 2=B}
System.out.println(map.get(1)); // A
System.out.println(map.size()); // 2
System.out.println(map.containsKey(1)); // true
System.out.println(map.keySet()); // [1,2]
System.out.println(map.isEmpty()); // false
System.out.println(map.entrySet()); // [1=A, 2=B]
```
### 2.  LinkedHashMap (Maintains Insertion Order)
- **Preserves insertion order.**
- **Slightly slower** than `HashMap`.

```java
Map<Integer, String> map = new LinkedHashMap<>();
map.put(1, "A");
map.put(2, "B");
System.out.println(map); // {1=A, 2=B}
System.out.println(map.get(1)); // A
System.out.println(map.size()); // 2
System.out.println(map.containsKey(1)); // true
System.out.println(map.keySet()); // [1,2]
System.out.println(map.isEmpty()); // false
System.out.println(map.entrySet()); // [1=A, 2=B]
```

### 3. TreeMap (Sorted Order)
- **Sorted by natural order of keys (ascending order by default).**
- **Does not allow** `null` keys but allows `null` values.
- **Slower** than `HashMap` due to sorting.
```java
Map<Integer, String> map = new TreeMap<>();
map.put(1, "A");
map.put(2, "B");
System.out.println(map); // {1=A, 2=B}
System.out.println(map.get(1)); // A
System.out.println(map.size()); // 2
System.out.println(map.containsKey(1)); // true
System.out.println(map.keySet()); // [1,2]
System.out.println(map.isEmpty()); // false
System.out.println(map.entrySet()); // [1=A, 2=B]
```

### 4. ConcurrentHashMap (Thread-Safe)
- **Used in multi-threaded environments.**
- Does not allow `null` keys or values.

```java
ConcurrentHashMap<Integer, String> concurrentHashMap = new ConcurrentHashMap<>();
map.put(1, "A");
map.put(2, "B");
System.out.println(map); // {1=A, 2=B}
System.out.println(map.get(1)); // A
System.out.println(map.size()); // 2
System.out.println(map.containsKey(1)); // true
System.out.println(map.keySet()); // [1,2]
System.out.println(map.isEmpty()); // false
System.out.println(map.entrySet()); // [1=A, 2=B]
```
### Uses Summary:
- Use `HashMap` when ordering is not important and you need fast lookups.
- Use `LinkedHashMap` when you need to preserve insertion order.
- Use `TreeMap` when you need sorted keys.
- Use `ConcurrentHashMap` when dealing with multi-threading.
- Use `WeakHashMap` when you want keys to be garbage-collected.
- Use `IdentityHashMap` if you need reference-based key comparison `(==)`.

## Example two extension of `map()`:
> The Collections Framework provides the Map interface, which is used to store key-value pairs. It also has two extensions:
- `SortedMap` – Ensures keys are sorted in natural order or using a comparator
- `NavigableMap` – Extends `SortedMap` by adding navigation methods like `higherKey()`, `lowerKey()`, `ceilingKey()`, and `floorKey()`.

## Hierarchy of Map Interface

```java
                Map<K, V>  (Interface)
                        │
                     Extends
        ┌───────────────┼──────────────────┐
        │               │                  │
    SortedMap                         NavigableMap 
```
            
### 1. SortedMap Interface (Sorted Keys)
- Ensures keys are stored in sorted order (ascending by default).
- Implemented by TreeMap.
```java
SortedMap<Integer, String> sortedMap = new TreeMap<>();
sortedMap.put(1, "A");
sortedMap.put(2, "B");
System.out.println(sortedMap.firstKey()); // 1
System.out.println(sortedMap.lastKey()); // 2
System.out.println(sortedMap.size()); // 2
System.out.println(sortedMap.isEmpty()); // false
System.out.println(sortedMap.keySet()); // [1, 2]
System.out.println(sortedMap.values()); // [A, B]
System.out.println(sortedMap.entrySet()); // [1=A, 2=B]
System.out.println(sortedMap.headMap(2)); //toKey: {1=A}
System.out.println(sortedMap.tailMap(1)); //fromKey: {1=A, 2=B}
```
### 2.  NavigableMap Interface (Advanced Navigation)
- **Extends** `SortedMap` and adds methods for key-based navigation.
- **Implemented** by `TreeMap`.
- **Provides methods like:**
    - `higherKey(k)` → Returns the next greater key.
    - `lowerKey(k)` → Returns the next smaller key.
    - `ceilingKey(k)` → Returns the next greater or equal key.
    - `floorKey(k)` → Returns the next smaller or equal key.
```java
NavigableMap<Integer, String> navigableMap = new TreeMap<>(sortedMap);
navigableMap.put(1, "A");
navigableMap.put(2, "B");
        
System.out.println(navigableMap.higherKey(1));
System.out.println(navigableMap.lowerEntry(2));
System.out.println(navigableMap.ceilingKey(1));
System.out.println(navigableMap.floorKey(1));
//Others methods
System.out.println(navigableMap.ceilingEntry(2));
System.out.println(navigableMap.descendingMap());
System.out.println(navigableMap.firstEntry());
System.out.println(navigableMap.lastEntry());
```

### Uses Summary:
- Use `HashMap` when you don’t need sorting.
- Use `TreeMap` if you need sorted keys `(SortedMap)`.
-  Use `TreeMap` with `NavigableMap` for advanced key navigation